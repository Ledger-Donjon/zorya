use parser::parser::{Inst, Var};

/// Focuses on implementing the execution of the CALLOTHER opcode from Ghidra's Pcode specification
/// This implementation relies on Ghidra 11.0.1 with the specfiles in /specfiles

#[derive(Debug)]
pub struct HandleCallOther {
    // PROBLEM : DEFINING A NEW STATE WILL INTERFERE WITH EXECUTOR.RS STATE
 }

impl<'a> HandleCallOther {

    // utiliser context Ã  la place de self (rust oop)

    pub fn handle_callother(&mut self, instruction: Inst) -> Result<(), String> {
        let operation_index = match instruction.inputs.get(0) {
            Some(Var::Const(index, _)) => *index,
            _ => return Err("CALLOTHER operation requires the first input to be a constant index".to_string()),
        };

        match operation_index {
            0x5 => self.handle_syscall(instruction),
            0xb => self.handle_rdtscp(instruction),
            0x10 => self.handle_swi(instruction),
            0x11 => self.handle_lock(instruction),
            0x12 => self.handle_unlock(instruction),
            0x2c => self.handle_cpuid(instruction),
            0x2d => self.handle_cpuid_basic_info(instruction),
            0x2e => self.handle_cpuid_version_info(instruction),
            0x2f => self.handle_cpuid_cache_tlb_info(instruction),
            0x30 => self.handle_cpuid_serial_info(instruction),
            0x31 => self.handle_cpuid_deterministic_cache_parameters_info(instruction),
            0x32 => self.handle_cpuid_monitor_mwait_features_info(instruction),
            0x33 => self.handle_cpuid_thermal_power_management_info(instruction),
            0x34 => self.handle_cpuid_extended_feature_enumeration_info(instruction),
            0x35 => self.handle_cpuid_direct_cache_access_info(instruction),
            0x36 => self.handle_cpuid_architectural_performance_monitoring_info(instruction),
            0x37 => self.handle_cpuid_extended_topology_info(instruction),
            0x38 => self.handle_cpuid_processor_extended_states_info(instruction),
            0x39 => self.handle_cpuid_quality_of_service_info(instruction),
            0x3a => self.handle_cpuid_brand_part1_info(instruction),
            0x3b => self.handle_cpuid_brand_part2_info(instruction),
            0x3c => self.handle_cpuid_brand_part3_info(instruction),
            0x4a => self.handle_rdtsc(instruction),
            0x97 => self.handle_pshufb(instruction),
            0x98 => self.handle_pshufhw(instruction),
            0xdc => self.handle_aesenc(instruction),
            0x13a => self.handle_vmovdqu_avx(instruction),
            0x144 => self.handle_vmovntdq_avx(instruction),
            0x1be => self.handle_vptest_avx(instruction),
            0x1c7 => self.handle_vpxor_avx(instruction),
            0x203 => self.handle_vpand_avx2(instruction),
            0x209 => self.handle_vpcmpeqb_avx2(instruction),
            0x25d => self.handle_vpbroadcastb_avx2(instruction),
            _ => return Err(format!("Unsupported CALLOTHER operation index: {:x}", operation_index)),
        }
    }

    pub fn handle_syscall(&mut self, instruction: Inst) -> Result<(), String> {
        let syscall_number = self.state.cpu_state.gpr.get("RAX").copied().ok_or("Syscall number not found")?;

        match syscall_number {
            0 => { // Syscall number for `read`
                let fd = self.state.cpu_state.gpr.get("RDI").copied().ok_or("File descriptor for read not found")?;
                let buf_addr = self.state.cpu_state.gpr.get("RSI").copied().ok_or("Buffer address for read not found")?;
                let count = self.state.cpu_state.gpr.get("RDX").copied().ok_or("Count for read not found")? as usize;

                // Prepare a buffer for reading data
                let mut buffer = vec![0u8; count];
                // Perform the read operation
                match self.state.vfs.read(fd, &mut buffer) {
                    Ok(bytes_read) => {
                        // Assuming a method to write data back to simulated memory is implemented
                        self.state.memory.write_memory(buf_addr, &buffer[..bytes_read]).map_err(|e| e.to_string())?;
                        self.state.cpu_state.gpr.insert("RAX".to_string(), bytes_read as u64); // Return the number of bytes read
                        Ok(())
                    },
                    Err(_) => Err("Failed to read from virtual file".to_string()),
                }
            },

            1 => { // Syscall number for `write`
                let fd = self.state.cpu_state.gpr.get("RDI").copied().ok_or("File descriptor for write not found")?;
                let buf_addr = self.state.cpu_state.gpr.get("RSI").copied().ok_or("Buffer address for write not found")?;
                let count = self.state.cpu_state.gpr.get("RDX").copied().ok_or("Count for write not found")? as usize;

                // Prepare a buffer to simulate data to write (In practice, this data should be fetched from your program's memory)
                let buffer = self.state.memory.read_memory(buf_addr, count).map_err(|e| e.to_string())?;

                // Perform the write operation
                match self.state.vfs.write(fd, &buffer) {
                    Ok(bytes_written) => {
                        self.state.cpu_state.gpr.insert("RAX".to_string(), bytes_written as u64); // Return the number of bytes written
                        Ok(())
                    },
                    Err(_) => Err("Failed to write to virtual file".to_string()),
                }
            },

            2 => { // Syscall number for `open`
                let path_addr = self.state.cpu_state.gpr.get("RDI").copied().ok_or("Path address for open not found")?;
                let flags = self.state.cpu_state.gpr.get("RSI").copied().ok_or("Flags for open not found")? as i32;
                // Optional ?
                let mode = self.state.cpu_state.gpr.get("RDX").copied().unwrap_or(0) as u32;

                // Fetch the file path string from memory
                let path = self.state.memory.read_string(path_addr).map_err(|e| e.to_string())?;

                let fd = self.state.vfs.open(&path, flags);
                self.state.cpu_state.gpr.insert("RAX".to_string(), fd); // Return file descriptor
                Ok(())
            },
            _ => Err(format!("Unsupported syscall with number {}", syscall_number)),
        }
    }


    fn handle_swi(&mut self, instruction: Inst) -> Result<(), String> {
        // Implement the swi operation handling logic
        Ok(())
    }

}