impl<'a> State<'a> {
    pub fn new(ctx: &'a Context, binary_path: &Path) -> io::Result<Self> {
        let cpu_state = CpuState::new();
        let memory_size: u64 = 0x1000000; // modify?

        let mut memory = MemoryX86_64::new(ctx, memory_size);

        // Load binary data into memory
        let mut file = File::open(binary_path)?;

        // Initialize memory sections based on LOAD commands
        Self::initialize_load_section(&mut file, &mut memory, 0x000000, 0x0000000000400000, 0x081b1a)?; // First LOAD
        Self::initialize_load_section(&mut file, &mut memory, 0x082000, 0x0000000000482000, 0x092328)?; // Second LOAD
        Self::initialize_load_section(&mut file, &mut memory, 0x115000, 0x0000000000515000, 0x017fa0)?; // Third LOAD

        // Initialize specific address
        Self::initialize_specific_address(&mut memory)?;

        Ok(State {
            concolic_vars: HashMap::new(),
            cpu_state,
            ctx,
            memory,
        })
    }

    fn initialize_load_section(file: &mut File, memory: &mut MemoryX86_64, file_offset: u64, memory_address: u64, size: u64) -> io::Result<()> {
        let mut buffer = vec![0; size as usize];
        file.seek(SeekFrom::Start(file_offset))?;
        file.read_exact(&mut buffer)?;
        for (i, &byte) in buffer.iter().enumerate() {
            memory.write_memory(memory_address + i as u64, &vec![byte]).unwrap_or_else(|_| panic!("Failed to write memory at address 0x{:x}", memory_address + i as u64));
        }
        Ok(())
    }

    pub fn initialize_specific_address(memory: &mut MemoryX86_64) -> io::Result<()> {
        // Example address and data
        let address = 0x556f6b17bf30;
        let data = [0x00]; // Example data to write, adjust as needed
    
        // Write the data to the specified address
        memory.write_memory(address, &data)
              .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))
    }
    
